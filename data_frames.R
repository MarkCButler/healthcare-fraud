# This script loads csv data and uses dplyr operations to create/manipulate
# data frames that are used for data analysis.

library(dplyr)
library(forcats)
library(lubridate)
library(purrr)
library(stringr)
library(tidyr)

source('vectors.R')

# nolint start
# (using nolint to avoid a linter complaint about commented code)

# The main data frames generated by this script are:
#
# 1.  na_counts -- a list of data frames, each characterizing missing values
#     in one of the csv files.  The unique row identifier for each data frame
#     of this list is a column name.
#
# 2. inpatient_claims, outpatient_claims -- data frames that have ClaimID as a
#    unique row identifier.
#
# 3. inpatients, outpatients -- data frames that have BeneID (patient ID) as a
#    unique row identifier.
#
# 4. inpatient_doctors, outpatient_doctors -- data frames that have a
#    physician ID as a unique row identifier.
#
# 5. inpatient_providers, outpatient_providers -- data frames that have
#    provider ID as a unique row identifier.
#
# 6. provider_claim_counts_inpatient, provider_claim_counts_outpatient -- data
#    frames that give monthly claim counts per provider.  The combination of
#    provider, year, month is a unique row identifier.
#
# 7. freq_admit_codes_inpatient, freq_admit_codes_outpatient -- data frames
#    that list the most admission codes, with admission code as a unique row
#    identifier.
#
# For each pair of data frames such as inpatient_claims, outpatient_claims,
# there is a list that facilitates looping over inpatient and outpatient
# without the need to perform a dplyr filter operation.  For instance, the
# definition
#
# claims <- list(
#     inpatient = inpatient_claims,
#     outpatient = outpatient_claims
# )
#
# enables loops such as the following without a dplyr filter command:
#
# for (claim_type in c('inpatient', 'outpatient') {
#     to_plot <- claims[[claim_type]]
#     <Visualize data for inpatients and outpatients in separate plots
#      using the to_plot data frame.>
# }
#
# There are many loops (including some inner loops) of this form in the
# current project, so avoiding the unnecessary filter operations is
# worthwhile.
#
# In cases where inpatient and outpatient data needs to be manipulated as a
# whole, a concatenated data frame is formed.  For instance, in assigning a
# single age to each patient, all claims are concatenated into a single data
# frame and grouped by patient ID.  The median age of the patient over all
# visits by the patient is chosen as the patient age.  If the concatenated
# data frame needs to be reused, _concatenated is appended to the variable
# name, e.g., patients_concatenated.

# nolint end


#############################################################################
# Load data from csv files.
#############################################################################

data_filenames <- list(
    train_outpatient = 'data/Train_Outpatientdata-1542865627584.csv',
    train_inpatient = 'data/Train_Inpatientdata-1542865627584.csv',
    train_provider = 'data/Train-1542865627584.csv',
    train_beneficiary = 'data/Train_Beneficiarydata-1542865627584.csv',
    test_outpatient = 'data/Test_Outpatientdata-1542969243754.csv',
    test_inpatient = 'data/Test_Inpatientdata-1542969243754.csv',
    test_provider = 'data/Test-1542969243754.csv',
    test_beneficiary = 'data/Test_Beneficiarydata-1542969243754.csv'
)

read_data <- function(file) {
    data <- read.csv(file, stringsAsFactors = FALSE,
                     na.strings = c('NA', ''))
    return(data)
}

data_frames <- map(data_filenames, read_data)


#############################################################################
# Variables used by functions in this script.
#############################################################################

# Names of columns that contain a code for a hospital visit.
all_claim_colnames <- union(colnames(data_frames$train_inpatient),
                            colnames(data_frames$train_outpatient))
bool_index <- str_detect(tolower(all_claim_colnames), 'code')
all_code_colnames <- all_claim_colnames[bool_index]


#############################################################################
# Helper functions for manipulating data frames.
#############################################################################

# Drop rows that have NA for all code columns.
filter_out_no_codes <- function(code_data) {
    code_colnames <- intersect(all_code_colnames, colnames(code_data))
    code_data <- code_data %>%
        select(ClaimID, all_of(code_colnames)) %>%
        mutate(across(all_of(code_colnames),
                      ~ !is.na(.))) %>%
        rowwise(ClaimID) %>%
        summarise(
            value_count = sum(c_across(all_of(code_colnames))),
            .groups = 'drop'
        ) %>%
        filter(value_count != 0) %>%
        select(-value_count) %>%
        left_join(code_data, by = 'ClaimID')
    return(code_data)
}

# Add the column PotentialFraud to a data frame.  The functions in the current
# script are designed to handle either training data or test data.  Some of
# them take a boolean argument that indicates whether the training data set is
# being processed.  If so, the function add_fraud_flag can be used to
# add the training label to a data frame that has a Provider column.
add_fraud_flag <- function(data) {
    data <- left_join(data, data_frames$train_provider, by = 'Provider')
    return(data)
}


#############################################################################
# Characterize missing values.
#############################################################################

# Characterize missing values, ignoring columns such as ClmDiagnosisCode_n and
# ClmProcedureCode_n.
get_na_counts <- function(data) {
    na_counts <- data.frame(name = colnames(data),
                            count = as.integer(colSums(is.na(data))),
                            stringsAsFactors = FALSE) %>%
        filter(str_detect(name, 'Clm.+Code', negate = TRUE)) %>%
        arrange(desc(count)) %>%
        filter(count != 0)
    return(na_counts)
}

na_counts <- map(data_frames, get_na_counts)


#############################################################################
# Combine data frames with inpatient and outpatient scope, labeling each row
# as 'inpatient', 'outpatient', or 'both'.
#############################################################################

combine_claim_types <- function(inpatient_data, outpatient_data, row_id,
                                include_fraud_counts = FALSE) {

    if (include_fraud_counts) {
        shared_row_id <- intersect(
            inpatient_data[[row_id]],
             outpatient_data[[row_id]]
        )
        both_claim_types <- inpatient_data %>%
            bind_rows(outpatient_data) %>%
            filter(if_all(row_id,
                          ~ (.) %in% shared_row_id)) %>%
            group_by(across(row_id)) %>%
            summarise(
                across(
                    c(claim_count, claim_count_fraud,
                      provider_count, provider_count_fraud),
                    sum
                ),
                .groups = 'drop'
            ) %>%
            mutate(
                claim_fraud_fraction = claim_count_fraud / claim_count,
                provider_fraud_fraction = provider_count_fraud / provider_count,
                claim_type = 'both'
            )
    } else{
        both_claim_types <- inpatient_data %>%
            semi_join(outpatient_data, by = row_id) %>%
            mutate(claim_type = 'both')
    }

    only_inpatient <- inpatient_data %>%
        anti_join(outpatient_data, by = row_id) %>%
        mutate(claim_type = 'inpatient only')
    only_outpatient <- outpatient_data %>%
        anti_join(inpatient_data, by = row_id) %>%
        mutate(claim_type = 'outpatient only')

    claim_type_levels <- c('inpatient only', 'outpatient only', 'both')
    combined <- bind_rows(both_claim_types,
                          only_inpatient,
                          only_outpatient) %>%
        mutate(claim_type = factor(claim_type, levels = claim_type_levels))

    return(combined)
}


#############################################################################
# Generate data frames that give information about duplicated claims.  These
# data frames are joined to the data frames inpatient_claims and outpatient
# claims using ClaimID.
#############################################################################

# Arguments:
#
#   claim_data:  data frame with rows that correspond to hospital visits
#
# The function uses dplyr operations to extract information about duplicate
# claims, i.e., claims with different ClaimID but identical values for all
# codes associated with the claim.
#
get_duplicates_data <- function(claim_data) {
    code_colnames <- intersect(all_code_colnames, colnames(claim_data))

    # Starting with claim_data, gradually build a code_data data frame with
    # information about duplicated codes.
    code_data <- claim_data %>%
        mutate(across(ClaimStartDt,
                      ~ as_date(., format = '%Y-%m-%d'))) %>%
        select(ClaimStartDt, ClaimID, Provider, all_of(code_colnames))

    code_data <- code_data %>%
        # For each claim, find how many identical claims there are (where
        # identical means "has exactly the same set of codes").  Also find how
        # many distinct providers filed an identical claim and the earliest
        # ClaimStartDt for each set of identical claims.
        group_by(across(all_of(code_colnames))) %>%
        summarise(identical_claim_count = n_distinct(ClaimID),
                  identical_claims_provider_count = n_distinct(Provider),
                  first_date = min(ClaimStartDt), .groups = 'drop') %>%
        mutate(identical_claims_per_provider = (
            identical_claim_count / identical_claims_provider_count
        )) %>%
        # Treating the set of codes for a claim as a row ID, join the new
        # columns to code_data.
        right_join(code_data, by = code_colnames) %>%
        # Add column 'original' indicating whether the ClaimStartDt for that
        # claim is the earliest among the set of identical claims.
        mutate(original = (ClaimStartDt == first_date))

    # For each set of identical claims, find how many rows are labeled as
    # original, i.e., how many have the earliest ClaimStartDt.  Add this as a
    # column to the full data frame code_data.
    code_data <- code_data %>%
        filter(original == TRUE) %>%
        group_by(across(all_of(code_colnames))) %>%
        summarise(original_claim_count = n(), .groups = 'drop') %>%
        right_join(code_data, by = code_colnames)

    # Next add a column determining whether the provider for a claim is one of
    # the providers for an "original" claim (i.e., a claim with the earliest
    # ClaimStartDt among identical claims).  This is done by first finding all
    # ClaimID's for which the provider is one of the original providers.
    code_data <- code_data %>%
        filter(original == TRUE) %>%
        select(Provider, all_of(code_colnames)) %>%
        distinct() %>%
        rename(original_provider = Provider) %>%
        right_join(code_data, by = code_colnames) %>%
        # This filtering step gives a data frame of claims that have one of
        # the original providers for the corresponding set of identical claims.
        filter(Provider == original_provider) %>%
        select(ClaimID) %>%
        mutate(provider_is_original = TRUE) %>%
        right_join(code_data, by = 'ClaimID') %>%
        replace_na(list(provider_is_original = FALSE)) %>%
        # The current function is part of a pipeline that generates data frame
        # with ClaimID as a row identifier.  Drop the column names that are
        # already present in that data frame.
        select(-ClaimStartDt, -Provider, -all_of(code_colnames))

    return(code_data)
}


#############################################################################
# Get a data frame giving information about the number of hospital claims per
# patient.  If training data is being processed, also give the number of
# claims per patient labeled as potential fraud.  (Strictly speaking, it is
# providers rather than claims that are labeled as potential fraud in the
# training data set.  Here any claim made by a potentially fraudulent provider
# is labeled as potentially fraudulent.)
#############################################################################

# Arguments:
#
#   claim_data:  data frame with rows that correspond to hospital visits
#   claim_type:  either 'inpatient' or 'outpatient'
#   training:  boolean indicating whether training data is being processed
#
get_patient_claim_counts <- function(claim_data, claim_type,
                                     training = TRUE) {

    if (training) {
        claim_data <- add_fraud_flag(claim_data)
        claim_counts <- claim_data %>%
            group_by(BeneID) %>%
            summarise(
                claim_count_fraud = sum(PotentialFraud == 'Yes'),
                claim_count = n(),
                .groups = 'drop'
            ) %>%
            mutate(
                claim_fraud_fraction = claim_count_fraud / claim_count
            )
    } else {
        claim_counts <- claim_data %>%
            group_by(BeneID) %>%
            summarise(claim_count = n(), .groups = 'drop')
    }

    claim_counts <- mutate(claim_counts, claim_type = .env$claim_type)

    return(claim_counts)
}

inpatient_claim_counts <- get_patient_claim_counts(
    claim_data =  data_frames$train_inpatient,
    claim_type = 'inpatient'
)
outpatient_claim_counts <- get_patient_claim_counts(
    claim_data = data_frames$train_outpatient,
    claim_type = 'outpatient'
)


#############################################################################
# Add columns to a data frame of claims, each representing a hospital visit.
#############################################################################

# For time-series analysis, we want dates binned into weekly periods.  In
# order to facilite time-series analysis, generate a data frame of dates
# corresponding to the beginning of each weekly period.  Avoid errors
# associated with partial weeks at the end of a year by using lubridate's
# isoweek and isoyear functions.
get_claim_dates <- function(inpatient_data, outpatient_data) {

    all_claim_dates <- c(inpatient_data$ClaimStartDt,
                         outpatient_data$ClaimStartDt) %>%
        as_date(format = '%Y-%m-%d')
    start_date <- min(all_claim_dates)
    end_date <- max(all_claim_dates)
    daily_dates <- seq(start_date, end_date, by = 1)

    weekly_dates <- data.frame(date = daily_dates) %>%
        mutate(year = isoyear(date), week = isoweek(date)) %>%
        group_by(year, week) %>%
        summarise(week_date = min(date), .groups = 'drop')

    claim_dates <- list(
        daily = data.frame(ClaimStartDt = daily_dates),
        weekly = weekly_dates
    )

    return(claim_dates)
}

claim_dates <- get_claim_dates(
    data_frames$train_inpatient, data_frames$train_outpatient
)

# Arguments:
#
#   claim_data:  data frame with rows that correspond to hospital visits
#   patient_data:  data frame with rows giving information about patients
#   claim_counts:  data frame with rows giving information about claim counts
#                  (grouped by patient)
#   training:  boolean indicating whether training data is being processed
#
# The function uses dplyr operations to add columns to the argument
# claim_data, which is then returned.
#
augment_claim_data <- function(claim_data, patient_data, claim_counts,
                               claim_type, training = TRUE) {
    duplicates_data <- get_duplicates_data(claim_data)

    claim_data <- claim_data %>%
        replace_na(list(DeductibleAmtPaid = 0)) %>%
        mutate(visit_cost = InscClaimAmtReimbursed + DeductibleAmtPaid) %>%
        mutate(across(c(ClaimStartDt, ClaimEndDt),
                      ~ as_date(., format = '%Y-%m-%d'))) %>%
        # A claim that ends on the same day it starts will be defined to have
        # a duration of one day.
        mutate(claim_duration = as.integer(ClaimEndDt - ClaimStartDt + 1)) %>%
        mutate(cost_per_claim_day = visit_cost / claim_duration) %>%
        mutate(year = isoyear(ClaimStartDt),
               week = isoweek(ClaimStartDt)) %>%
        left_join(claim_dates$weekly, by = c('year', 'week')) %>%
        select(-c(year, week)) %>%
        left_join(claim_counts, by = 'BeneID')
    if (claim_type == 'inpatient') {
        claim_data <- claim_data %>%
            mutate(across(c(AdmissionDt, DischargeDt),
                          ~ as_date(., format = '%Y-%m-%d'))) %>%
            # A visit that ends on the same day it starts will be defined to
            # have a duration of one day.
            mutate(
                visit_duration = as.integer(DischargeDt - AdmissionDt + 1)
            ) %>%
            mutate(cost_per_visit_day = visit_cost / visit_duration)
    }
    patient_data <- patient_data %>%
        select(BeneID, DOB, DOD) %>%
        mutate(across(c(DOB, DOD),
                      ~ as_date(., format = '%Y-%m-%d')))
    claim_data <- left_join(claim_data, patient_data, by = 'BeneID') %>%
        mutate(patient_age = as.numeric(ClaimStartDt - DOB) / 365.24) %>%
        left_join(duplicates_data, by = 'ClaimID')

    if (training) {
        claim_data <- add_fraud_flag(claim_data)
    }

    return(claim_data)
}

inpatient_claims <- augment_claim_data(
    claim_data = data_frames$train_inpatient,
    patient_data = data_frames$train_beneficiary,
    claim_counts = inpatient_claim_counts,
    claim_type = 'inpatient'
)
outpatient_claims <- augment_claim_data(
    claim_data = data_frames$train_outpatient,
    patient_data =  data_frames$train_beneficiary,
    claim_counts =  outpatient_claim_counts,
    claim_type = 'outpatient'
)
claims <- list(
    inpatient = inpatient_claims,
    outpatient = outpatient_claims
)

# Concatenate inpatient_claims and outpatient_claims, including only columns
# needed elsewhere in the project.  The columns are BeneID, patient_age,
# potential_fraud, claim_type.
claims_concatenated <- inpatient_claims %>%
    select(BeneID, patient_age, PotentialFraud, claim_type) %>%
    bind_rows(
        select(outpatient_claims,
               BeneID, patient_age, PotentialFraud, claim_type)
    )


#############################################################################
# Add columns to a data frame of hospital patients.
#############################################################################

# For each patient, calculate the median age of that patient during the
# hospital visits in the data set.  (The visits occurred within roughly a
# year-long period.)  Note that both inpatient and outpatient visits in the
# calculation of the median.
patient_ages <- claims_concatenated %>%
    group_by(BeneID) %>%
    summarise(age = median(patient_age), .groups = 'drop')

# Arguments:
#
#   patient_data:  data frame with rows giving information about patients
#   claim_data:  data frame with rows that correspond to hospital visits
#   claim_counts:  data frame with rows giving information about claim counts
#                  (grouped by patient)
#
# The function uses dplyr operations to add columns to the argument
# patient_data, which is then returned.
#
augment_patient_data <- function(patient_data, claim_data, claim_counts,
                                 training = TRUE) {

    patient_data <- patient_data %>%
        filter(BeneID %in% claim_data$BeneID) %>%
        rename_with(.fn = clean_condition_names,
                    .cols = all_of(chronic_conditions_raw)) %>%
        mutate(across(all_of(chronic_conditions),
                      ~ fct_recode(factor(.), 'Y' = '1', 'N' = '2'))) %>%
        mutate(state_name = state_codes[State])

    condition_counts <- patient_data %>%
        select(BeneID, all_of(chronic_conditions)) %>%
        mutate(across(all_of(chronic_conditions),
                      ~ (.) == 'Y')) %>%
        rowwise(BeneID) %>%
        summarise(
            condition_count = sum(c_across(all_of(chronic_conditions))),
            .groups = 'drop'
        )

    if (training) {
        provider_counts <- claim_data %>%
            select(Provider, BeneID) %>%
            distinct() %>%
            add_fraud_flag() %>%
            group_by(BeneID) %>%
            summarise(provider_count = n(),
                      provider_count_fraud = sum(PotentialFraud == 'Yes'),
                      .groups = 'drop') %>%
            mutate(
                provider_fraud_fraction = provider_count_fraud / provider_count
            )
    } else {
        provider_counts <- claim_data %>%
            select(Provider, BeneID) %>%
            distinct() %>%
            group_by(BeneID) %>%
            summarise(provider_count = n(), .groups = 'drop')
    }


    # For both the training and test sets, the inpatient data frame has
    # missing values for DeductibleAmtPaid.  In all cases where the value is
    # not missing in the inpatient data frame, it is $1068.
    #
    # It is reasonable to guess that for inpatient visits, the value of NA
    # correspond to visits in which the deductible was 0.
    #
    # For the outpatient data frames, however, there are many zero values in
    # DeductibleAmtPaid but no missing values.
    #
    # However, it appears that there are missing values in
    # InscClaimAmtReimbursed and DeductibleAmtPaid for both the inpatient and
    # outpatient data.  For a number of rows, InscClaimAmtReimbursed and
    # DeductibleAmtPaid are both zero, which gives a cost of zero for the
    # visit to the hospital.  For the training set of outpatient visits, for
    # instance, there are about 19k rows like this (out of about 520k). Data
    # analysis involving vist cost needs to take account of this.
    payments <- claim_data %>%
        select(BeneID, InscClaimAmtReimbursed, DeductibleAmtPaid) %>%
        replace_na(list(DeductibleAmtPaid = 0)) %>%
        mutate(visit_cost = InscClaimAmtReimbursed + DeductibleAmtPaid) %>%
        filter(visit_cost != 0) %>%
        select(-DeductibleAmtPaid) %>%
        group_by(BeneID) %>%
        summarise(
            total_reimbursed = sum(InscClaimAmtReimbursed),
            reimbursed_per_visit = mean(InscClaimAmtReimbursed),
            total_cost_of_claims = sum(visit_cost),
            claim_cost_per_visit = mean(visit_cost),
            .groups = 'drop'
        )

    patient_data <- patient_data %>%
        left_join(payments, by = 'BeneID') %>%
        left_join(patient_ages, by = 'BeneID') %>%
        left_join(provider_counts, by = 'BeneID') %>%
        left_join(claim_counts, by = 'BeneID') %>%
        left_join(condition_counts, by = 'BeneID')

    return(patient_data)
}

inpatients <- augment_patient_data(
    patient_data =  data_frames$train_beneficiary,
    claim_data =  data_frames$train_inpatient,
    claim_counts = inpatient_claim_counts
)
outpatients <- augment_patient_data(
    patient_data =  data_frames$train_beneficiary,
    claim_data =  data_frames$train_outpatient,
    claim_counts =  outpatient_claim_counts
)
patients <- list(
    inpatient = inpatients,
    outpatient = outpatients
)
patients_concatenated <- bind_rows(
    inpatients,
    outpatients
)
to_select <- c('BeneID', fraud_count_colnames)
patients_combined <- combine_claim_types(
    select(inpatients, all_of(to_select)),
    select(outpatients, all_of(to_select)),
    row_id = 'BeneID',
    include_fraud_counts = TRUE
)


#############################################################################
# Generate a data frame of doctor information, i.e., with doctors as
# observations.
#############################################################################

# Arguments:
#
#   claim_data:  data frame with rows that correspond to hospital visits
#   claim_type:  either 'inpatient' or 'outpatient'
#   training:  boolean indicating whether training data is being processed
#
# The function uses dplyr operations to extract information about doctors and
# generate a data frame with doctors as observations.
#
get_doctor_data <- function(claim_data, claim_type, training = TRUE) {

    if (training) {
        claim_data <- add_fraud_flag(claim_data)
        to_select <- c('Provider', 'ClaimID', 'PotentialFraud',
                       all_of(doctor_colnames))
    } else {
        to_select <- c('Provider', 'ClaimID',
                       all_of(doctor_colnames))
    }

    doctor_data <- claim_data %>%
        select(all_of(to_select)) %>%
        pivot_longer(all_of(doctor_colnames), names_to = 'role',
                     values_to = 'doctor') %>%
        select(-role) %>%
        drop_na(doctor) %>%
        distinct()

    # The choice of summary columns to add depends on whether the training
    # label is present.
    if (training) {
        count_data <- doctor_data %>%
            group_by(doctor) %>%
            summarise(
                claim_count = n(),
                claim_count_fraud = sum(PotentialFraud == 'Yes'),
                provider_count = n_distinct(Provider),
                .groups = 'drop'
            ) %>%
            mutate(
                claim_fraud_fraction = claim_count_fraud / claim_count
            )
        doctor_data <- doctor_data %>%
            filter(PotentialFraud == 'Yes') %>%
            group_by(doctor) %>%
            summarise(provider_count_fraud = n_distinct(Provider),
                      .groups = 'drop') %>%
            right_join(count_data, by = 'doctor') %>%
            replace_na(list(provider_count_fraud = 0)) %>%
            mutate(
                provider_fraud_fraction = provider_count_fraud / provider_count
            )
    } else {
        doctor_data <- doctor_data %>%
            group_by(doctor) %>%
            summarise(
                claim_count = n(),
                provider_count = n_distinct(Provider),
                .groups = 'drop'
            )
    }

    doctor_data <- mutate(doctor_data, claim_type = .env$claim_type)

    return(doctor_data)
}

inpatient_doctors <- get_doctor_data(
    data_frames$train_inpatient,
    'inpatient'
)
outpatient_doctors <- get_doctor_data(
    data_frames$train_outpatient,
    'outpatient'
)
doctors <- list(
    inpatient = inpatient_doctors,
    outpatient = outpatient_doctors
)
to_select <- c('doctor', fraud_count_colnames)
doctors_combined <- combine_claim_types(
    select(inpatient_doctors, all_of(to_select)),
    select(outpatient_doctors, all_of(to_select)),
    row_id = 'doctor',
    include_fraud_counts = TRUE
)


#############################################################################
# Generate data frames of provider information.
#############################################################################

# Arguments:
#
#   claim_data:  data frame with rows that correspond to hospital visits
#   claim_type:  either 'inpatient' or 'outpatient'
#   training:  boolean indicating whether training data is being processed
#
# The function uses dplyr operations to extract information about monthly
# claim counts per provider
#
get_provider_claim_counts <- function(claim_data, claim_type,
                                      training = TRUE) {
    claim_counts <- claim_data %>%
        mutate(
            ClaimStartDt = as_date(ClaimStartDt, format = '%Y-%m-%d')
        ) %>%
        mutate(
            claim_year = year(ClaimStartDt),
            claim_month = month(ClaimStartDt, label = TRUE, abbr = TRUE)
        ) %>%
        group_by(Provider, claim_year, claim_month) %>%
        summarise(claim_count = n(), .groups = 'drop') %>%
        mutate(claim_type = .env$claim_type)
    if (training) {
        claim_counts <- add_fraud_flag(claim_counts)
    }
    return(claim_counts)
}

provider_claim_counts_inpatient <- get_provider_claim_counts(
    data_frames$train_inpatient,
    'inpatient'
)
provider_claim_counts_outpatient <- get_provider_claim_counts(
    data_frames$train_outpatient,
    'outpatient'
)
provider_claim_counts <- list(
    inpatient = provider_claim_counts_inpatient,
    outpatient = provider_claim_counts_outpatient
)

# Arguments:
#
#   claim_data:  data frame with rows that correspond to hospital visits
#   claim_type:  either 'inpatient' or 'outpatient'
#   training:  boolean indicating whether training data is being processed
#
# The function uses dplyr operations to generate a data frame of provider
# information.
#
get_provider_data <- function(claim_data, claim_type, training = TRUE) {
    provider_data <- claim_data %>%
        mutate(across(c(ClaimStartDt, ClaimEndDt),
                      ~ as_date(., format = '%Y-%m-%d'))) %>%
        # A claim that ends on the same day it starts will be defined to have
        # a duration of one day.
        mutate(claim_duration = ClaimEndDt - ClaimStartDt + 1) %>%
        group_by(Provider) %>%
        summarise(mean_claim_duration = mean(claim_duration),
                  .groups = 'drop') %>%
        mutate(claim_type = .env$claim_type)
    if (training) {
        provider_data <- add_fraud_flag(provider_data)
    }
    return(provider_data)
}

inpatient_providers <- get_provider_data(
    claim_data = data_frames$train_inpatient,
    claim_type = 'inpatient'
)
outpatient_providers <- get_provider_data(
    claim_data = data_frames$train_outpatient,
    claim_type = 'outpatient'
)
providers <- list(
    inpatient = inpatient_providers,
    outpatient = outpatient_providers
)
providers_combined <- combine_claim_types(
    select(inpatient_providers, Provider, PotentialFraud),
    select(outpatient_providers, Provider, PotentialFraud),
    row_id = 'Provider'
)


#############################################################################
# Generate a data frame that gives information about the diagnosis codes most
# frequently used when a patient is admitted.
#############################################################################

# Arguments:
#
#   claim_data:  data frame with rows that correspond to hospital visits
#   claim_type:  either 'inpatient' or 'outpatient'
#
# The function uses dplyr operations to extract information about the most
# frequent admission codes and generate a data frame with the frequent
# admission codes as observations.
#
find_frequent_codes <- function(claim_data, claim_type) {
    frequent_codes <- claim_data %>%
        mutate(code = ClmAdmitDiagnosisCode) %>%
        group_by(code) %>%
        summarise(count = n(), .groups = 'drop') %>%
        drop_na() %>%
        arrange(desc(count)) %>%
        head(n = 5) %>%
        mutate(description = code_descriptions[code],
               claim_type = .env$claim_type)
    return(frequent_codes)
}
freq_admit_codes_inpatient <- find_frequent_codes(
    data_frames$train_inpatient,
    'inpatient'
)
freq_admit_codes_outpatient <- find_frequent_codes(
    data_frames$train_outpatient,
    'outpatient'
)
freq_admit_codes <- list(
    inpatient = freq_admit_codes_inpatient,
    outpatient = freq_admit_codes_outpatient
)
